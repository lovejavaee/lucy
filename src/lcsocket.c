/* lcsocket.c generated by valac 0.20.1, the Vala compiler
 * generated from lcsocket.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include "lcsocket.h"
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define _g_free0(var) (var = (g_free (var), NULL))

struct _LcSocketPrivate {
    gboolean busy;
    gchar *addr;
    guint16 port;
};

void lc_socket_set_busy(LcSocket * socket, gboolean busy)
{
    socket->priv->busy = busy;
}

gboolean lc_socket_is_busy(LcSocket * socket)
{
    return socket->priv->busy;
}

static gpointer lc_socket_parent_class = NULL;

#define LC_SOCKET_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_LC_SOCKET, LcSocketPrivate))
enum {
    LC_SOCKET_DUMMY_PROPERTY
};
static void lc_socket_finalize(GObject * obj);


LcSocket *lc_socket_construct(GType object_type, const gchar * addr,
                              guint16 port)
{
    LcSocket *self = NULL;
    g_return_val_if_fail(addr != NULL, NULL);
    self = (LcSocket *) g_initable_new(object_type,
                                       NULL, NULL,
                                       "protocol", G_SOCKET_PROTOCOL_TCP,
                                       "type", G_SOCKET_TYPE_STREAM,
                                       "family", G_SOCKET_FAMILY_IPV4,
                                       "timeout", 15, NULL);
    self->priv->busy = FALSE;
    self->priv->addr = g_strdup(addr);
    self->priv->port = port;
    return self;
}


LcSocket *lc_socket_new(const gchar * addr, guint16 port)
{
    return lc_socket_construct(TYPE_LC_SOCKET, addr, port);
}


static void lc_socket_class_init(LcSocketClass * klass)
{
    lc_socket_parent_class = g_type_class_peek_parent(klass);
    g_type_class_add_private(klass, sizeof(LcSocketPrivate));
    G_OBJECT_CLASS(klass)->finalize = lc_socket_finalize;
}


static void lc_socket_instance_init(LcSocket * self)
{
    self->priv = LC_SOCKET_GET_PRIVATE(self);
}


static void lc_socket_finalize(GObject * obj)
{
    LcSocket *self;
    self = G_TYPE_CHECK_INSTANCE_CAST(obj, TYPE_LC_SOCKET, LcSocket);
    _g_free0(self->priv->addr);
    G_OBJECT_CLASS(lc_socket_parent_class)->finalize(obj);
}


GType lc_socket_get_type(void)
{
    static volatile gsize lc_socket_type_id__volatile = 0;
    if (g_once_init_enter(&lc_socket_type_id__volatile)) {
        static const GTypeInfo g_define_type_info =
            { sizeof(LcSocketClass), (GBaseInitFunc) NULL,
            (GBaseFinalizeFunc) NULL,
            (GClassInitFunc) lc_socket_class_init,
            (GClassFinalizeFunc) NULL, NULL,
            sizeof(LcSocket), 0,
            (GInstanceInitFunc) lc_socket_instance_init, NULL
        };
        GType lc_socket_type_id;
        lc_socket_type_id =
            g_type_register_static(g_socket_get_type(), "LcSocket",
                                   &g_define_type_info, 0);
        g_once_init_leave(&lc_socket_type_id__volatile, lc_socket_type_id);
    }
    return lc_socket_type_id__volatile;
}

void lc_socket_close(LcSocket * socket)
{
    g_socket_close(G_SOCKET(socket), NULL);
}

gboolean lc_socket_connect(LcSocket * socket)
{
    lc_socket_set_busy(socket, TRUE);
    struct sockaddr_in addr;
    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = inet_addr(socket->priv->addr);
    addr.sin_port = htons(socket->priv->port);
    GSocketAddress *address =
        g_socket_address_new_from_native((gpointer) & addr,
                                         sizeof(struct sockaddr_in));

    gboolean ret = g_socket_connect(G_SOCKET(socket), address, NULL, NULL);

    lc_socket_set_busy(socket, FALSE);
    return ret;
}


static void lc_socket_connect_async_thread(GTask * task,
                                           gpointer source_object,
                                           gpointer task_data,
                                           GCancellable * cancellable)
{
    LcSocket *socket = LC_SOCKET(source_object);
    gboolean ret = lc_socket_connect(socket);
    g_task_return_boolean(task, ret);
}

void lc_socket_connect_async(LcSocket * socket,
                             GAsyncReadyCallback callback,
                             gpointer user_data)
{
    GTask *task = g_task_new(socket, NULL, callback, user_data);
    lc_socket_set_busy(socket, TRUE);
    g_task_run_in_thread(task, lc_socket_connect_async_thread);
}

gboolean lc_socket_connect_async_finish(GAsyncResult * res)
{
    LcSocket *socket = (LcSocket *) g_task_get_source_object(G_TASK(res));
    lc_socket_set_busy(socket, FALSE);
    return g_task_propagate_boolean(G_TASK(res), NULL);
}

gssize lc_socket_send(LcSocket * socket, const gchar * buffer, gsize size)
{
    return g_socket_send(G_SOCKET(socket), buffer, size, NULL, NULL);
}

gssize lc_socket_receive(LcSocket * socket, gchar * buffer, gsize size)
{
    GError *error = NULL;
    gssize ret =
        g_socket_receive(G_SOCKET(socket), buffer, size, NULL, &error);
    if (error) {
        g_message("Receive From Socket Error:%s", error->message);
        g_error_free(error);
    }
    return ret;
}

gssize lc_data_length(gchar buf[4])
{
    int i, j;
    int ret = 0;
    for (i = 0; i < 4; i++) {
        int power = 3 - i;
        int base = 1;
        for (j = 0; j < power; j++) {
            base = base * 16;
        }
        int times = 0;
        if (buf[i] >= '0' && buf[i] <= '9') {
            times = buf[i] - '0';
        } else if (buf[i] >= 'a' && buf[i] <= 'f') {
            times = buf[i] - 'a' + 10;
        } else if (buf[i] >= 'A' && buf[i] <= 'F') {
            times = buf[i] - 'A' + 10;
        } else {
            return -1;
        }
        ret += times * base;
    }
    return ret;
}

GByteArray *lc_socket_send_command(LcSocket * socket,
                                   const gchar * command)
{
    GByteArray *array = NULL;

    lc_socket_set_busy(socket, TRUE);
    if (lc_socket_send(socket, command, strlen(command)) <= 0) {
        goto ERROR;
    }
    gchar buf[4096];
    gssize n;
    n = lc_socket_receive(socket, buf, 4);
    if (n != 4) {
        goto ERROR;
    }
    gssize length = lc_data_length(buf);
    if (length < 4) {           /* the response must be longer than 4 */
        goto ERROR;
    }
    array = g_byte_array_sized_new(4096);
    while (length > 0
           && (n = lc_socket_receive(socket, buf, sizeof(buf))) > 0) {
        g_byte_array_append(array, (guint8 *) buf, n);
        length -= n;
    }
    if (length != 0) {
        goto ERROR;
    }
    lc_socket_set_busy(socket, FALSE);
    return array;
  ERROR:
    if (array) {
        g_byte_array_free(array, TRUE);
    }
    lc_socket_set_busy(socket, FALSE);
    lc_socket_close(socket);
    return NULL;
}

/*
 * 该函数会发送一个协议请求，
 * 然后等待响应，直到接受到了完整的响应（一个空行结束）才回调
 */
static void lc_socket_send_command_async_thread(GTask * task,
                                                gpointer source_object,
                                                gpointer task_data,
                                                GCancellable * cancellable)
{
    /*
     * 如果是链接错误则返回NULL，否则返回接受到的数据（不包括长度）
     */
    LcSocket *socket = LC_SOCKET(source_object);
    const gchar *command = (gchar *) g_task_get_task_data(task);

    GByteArray *array = lc_socket_send_command(socket, command);
    g_task_return_pointer(task, array,
                          (GDestroyNotify) g_byte_array_unref);
}

void lc_socket_send_command_async(LcSocket * socket,
                                  const gchar * command,
                                  GAsyncReadyCallback callback,
                                  gpointer user_data)
{
    GTask *task = g_task_new(socket, NULL, callback, user_data);
    g_task_set_task_data(task, g_strdup(command), (GDestroyNotify) g_free);
    lc_socket_set_busy(socket, TRUE);
    g_task_run_in_thread(task, lc_socket_send_command_async_thread);
}

GByteArray *lc_socket_send_command_async_finish(GAsyncResult * result)
{
    LcSocket *socket =
        (LcSocket *) g_task_get_source_object(G_TASK(result));
    lc_socket_set_busy(socket, FALSE);
    return (GByteArray *) g_task_propagate_pointer(G_TASK(result), NULL);
}
