/* lcsocket.c generated by valac 0.20.1, the Vala compiler
 * generated from lcsocket.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include "lcsocket.h"
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define _g_free0(var) (var = (g_free (var), NULL))

/****************保存所有已存在的LcSocket**********************/
static GList *sockets_container = NULL;
/***************************************************************/

struct _LcSocketPrivate {
    gboolean busy;
    gchar *addr;
    guint16 port;
};

static void lc_socket_set_busy(LcSocket * socket, gboolean busy)
{
    socket->priv->busy = busy;
}

static gboolean lc_socket_is_busy(LcSocket * socket)
{
    return socket->priv->busy;
}

static gpointer lc_socket_parent_class = NULL;

#define LC_SOCKET_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_LC_SOCKET, LcSocketPrivate))
enum {
    LC_SOCKET_DUMMY_PROPERTY
};
static void lc_socket_finalize(GObject * obj);


LcSocket *lc_socket_construct(GType object_type, const gchar * addr,
                                guint16 port)
{
    LcSocket *self = NULL;
    g_return_val_if_fail(addr != NULL, NULL);
    self = (LcSocket *) g_object_new(object_type, NULL);
    self->priv->busy = FALSE;
    self->priv->addr = g_strdup(addr);
    self->priv->port = port;

    /* 新创建的LcSocket放到链表末尾 */
    sockets_container = g_list_append(sockets_container, self);
    return self;
}


LcSocket *lc_socket_new(const gchar * addr, guint16 port)
{
    return lc_socket_construct(TYPE_LC_SOCKET, addr, port);
}


static void lc_socket_class_init(LcSocketClass * klass)
{
    lc_socket_parent_class = g_type_class_peek_parent(klass);
    g_type_class_add_private(klass, sizeof(LcSocketPrivate));
    G_OBJECT_CLASS(klass)->finalize = lc_socket_finalize;
}


static void lc_socket_instance_init(LcSocket * self)
{
    self->priv = LC_SOCKET_GET_PRIVATE(self);
}


static void lc_socket_finalize(GObject * obj)
{
    LcSocket *self;
    self = G_TYPE_CHECK_INSTANCE_CAST(obj, TYPE_LC_SOCKET, LcSocket);
    _g_free0(self->priv->addr);
    G_OBJECT_CLASS(lc_socket_parent_class)->finalize(obj);
}


GType lc_socket_get_type(void)
{
    static volatile gsize lc_socket_type_id__volatile = 0;
    if (g_once_init_enter(&lc_socket_type_id__volatile)) {
        static const GTypeInfo g_define_type_info =
            { sizeof(LcSocketClass), (GBaseInitFunc) NULL,
            (GBaseFinalizeFunc) NULL,
                (GClassInitFunc) lc_socket_class_init,
                (GClassFinalizeFunc) NULL, NULL,
            sizeof(LcSocket), 0,
                (GInstanceInitFunc) lc_socket_instance_init, NULL
        };
        GType lc_socket_type_id;
        lc_socket_type_id =
            g_type_register_static(g_socket_get_type(), "LcSocket",
                                   &g_define_type_info, 0);
        g_once_init_leave(&lc_socket_type_id__volatile,
                          lc_socket_type_id);
    }
    return lc_socket_type_id__volatile;
}


static void lc_socket_connect_thread(GTask * task,
                                      gpointer source_object,
                                      gpointer task_data,
                                      GCancellable * cancellable)
{
    LcSocket *socket = LC_SOCKET(source_object);
    struct sockaddr_in addr;
    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = inet_addr(socket->priv->addr);
    addr.sin_port = htons(socket->priv->port);
    GSocketAddress *address =
        g_socket_address_new_from_native((gpointer) & addr,
                                         sizeof(struct sockaddr_in));
    gboolean ret = g_socket_connect(G_SOCKET(socket), address, NULL, NULL);
    g_task_return_boolean(task, ret);
}

void lc_socket_connect_async(LcSocket * socket,
                              GAsyncReadyCallback callback,
                              gpointer user_data)
{
    GTask *task = g_task_new(socket, NULL, callback, user_data);
    g_task_run_in_thread(task, lc_socket_connect_thread);
}

gboolean lc_socket_connect_finish(GAsyncResult * res)
{
    return g_task_propagate_boolean(G_TASK(res), NULL);
}

gssize lc_socket_send(LcSocket * socket, const gchar * buffer,
                       gsize size)
{
    return g_socket_send(G_SOCKET(socket), buffer, size, NULL, NULL);
}

gssize lc_socket_receive(LcSocket * socket, gchar * buffer, gsize size)
{
    return g_socket_receive(G_SOCKET(socket), buffer, size, NULL, NULL);
}

/* 读取一行 TODO */
gssize lc_socket_receive_line(LcSocket * socket, gchar * buffer,
                               gsize size)
{
    return 0;
}

/*
 * 该函数会发送一个协议请求，
 * 然后等待响应，直到接受到了完整的响应（一个空行结束）才回调
 */
static void lc_socket_send_command_thread(GTask * task,
                                           gpointer source_object,
                                           gpointer task_data,
                                           GCancellable * cancellable)
{
    LcSocket *socket = LC_SOCKET(source_object);
    const gchar *command = (gchar *) g_task_get_task_data(task);

    if (lc_socket_send(socket, command, -1) <= 0) {
        g_task_return_pointer(task, NULL, NULL);
    }
    GString *string = g_string_new("");
    gchar buf[4096];
    while (lc_socket_receive_line(socket, buf, sizeof(buf)) > 0) {
        /* TODO */
    }
}

void lc_socket_send_command_async(LcSocket * socket,
                                   const gchar * command,
                                   GAsyncReadyCallback callback,
                                   gpointer user_data)
{
    GTask *task = g_task_new(socket, NULL, callback, user_data);
    g_task_set_task_data(task, g_strdup(command), (GDestroyNotify) g_free);
    g_task_run_in_thread(task, lc_socket_send_command_thread);
    lc_socket_set_busy(socket, TRUE);
}

gchar *lc_socket_send_command_finish(GAsyncResult * result)
{
    gchar *data = (gchar *) g_task_propagate_pointer(G_TASK(result), NULL);
    LcSocket *socket =
        (LcSocket *) g_task_get_source_object(G_TASK(result));
    lc_socket_set_busy(socket, FALSE);
    return data;
}
