/* amlsocket.c generated by valac 0.20.1, the Vala compiler
 * generated from amlsocket.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include "amlsocket.h"
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define _g_free0(var) (var = (g_free (var), NULL))

/****************保存所有已存在的AmlSocket**********************/
static GList *sockets_container = NULL;
/***************************************************************/

struct _AmlSocketPrivate {
    gboolean busy;
    gchar *addr;
    guint16 port;
};

static void aml_socket_set_busy(AmlSocket * socket, gboolean busy)
{
    socket->priv->busy = busy;
}

static gboolean aml_socket_is_busy(AmlSocket * socket)
{
    return socket->priv->busy;
}

static gpointer aml_socket_parent_class = NULL;

#define AML_SOCKET_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_AML_SOCKET, AmlSocketPrivate))
enum {
    AML_SOCKET_DUMMY_PROPERTY
};
static void aml_socket_finalize(GObject * obj);


AmlSocket *aml_socket_construct(GType object_type, const gchar * addr,
                                guint16 port)
{
    AmlSocket *self = NULL;
    g_return_val_if_fail(addr != NULL, NULL);
    self = (AmlSocket *) g_object_new(object_type, NULL);
    self->priv->busy = FALSE;
    self->priv->addr = g_strdup(addr);
    self->priv->port = port;

    /* 新创建的AmlSocket放到链表末尾 */
    sockets_container = g_list_append(sockets_container, self);
    return self;
}


AmlSocket *aml_socket_new(const gchar * addr, guint16 port)
{
    return aml_socket_construct(TYPE_AML_SOCKET, addr, port);
}


static void aml_socket_class_init(AmlSocketClass * klass)
{
    aml_socket_parent_class = g_type_class_peek_parent(klass);
    g_type_class_add_private(klass, sizeof(AmlSocketPrivate));
    G_OBJECT_CLASS(klass)->finalize = aml_socket_finalize;
}


static void aml_socket_instance_init(AmlSocket * self)
{
    self->priv = AML_SOCKET_GET_PRIVATE(self);
}


static void aml_socket_finalize(GObject * obj)
{
    AmlSocket *self;
    self = G_TYPE_CHECK_INSTANCE_CAST(obj, TYPE_AML_SOCKET, AmlSocket);
    _g_free0(self->priv->addr);
    G_OBJECT_CLASS(aml_socket_parent_class)->finalize(obj);
}


GType aml_socket_get_type(void)
{
    static volatile gsize aml_socket_type_id__volatile = 0;
    if (g_once_init_enter(&aml_socket_type_id__volatile)) {
        static const GTypeInfo g_define_type_info =
            { sizeof(AmlSocketClass), (GBaseInitFunc) NULL,
            (GBaseFinalizeFunc) NULL,
                (GClassInitFunc) aml_socket_class_init,
                (GClassFinalizeFunc) NULL, NULL,
            sizeof(AmlSocket), 0,
                (GInstanceInitFunc) aml_socket_instance_init, NULL
        };
        GType aml_socket_type_id;
        aml_socket_type_id =
            g_type_register_static(g_socket_get_type(), "AmlSocket",
                                   &g_define_type_info, 0);
        g_once_init_leave(&aml_socket_type_id__volatile,
                          aml_socket_type_id);
    }
    return aml_socket_type_id__volatile;
}


static void aml_socket_connect_thread(GTask * task,
                                      gpointer source_object,
                                      gpointer task_data,
                                      GCancellable * cancellable)
{
    AmlSocket *socket = AML_SOCKET(source_object);
    struct sockaddr_in addr;
    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = inet_addr(socket->priv->addr);
    addr.sin_port = htons(socket->priv->port);
    GSocketAddress *address =
        g_socket_address_new_from_native((gpointer) & addr,
                                         sizeof(struct sockaddr_in));
    gboolean ret = g_socket_connect(G_SOCKET(socket), address, NULL, NULL);
    g_task_return_boolean(task, ret);
}

void aml_socket_connect_async(AmlSocket * socket,
                              GAsyncReadyCallback callback,
                              gpointer user_data)
{
    GTask *task = g_task_new(socket, NULL, callback, user_data);
    g_task_run_in_thread(task, aml_socket_connect_thread);
}

gboolean aml_socket_connect_finish(GAsyncResult * res)
{
    return g_task_propagate_boolean(G_TASK(res), NULL);
}

gssize aml_socket_send(AmlSocket * socket, const gchar * buffer,
                       gsize size)
{
    return g_socket_send(G_SOCKET(socket), buffer, size, NULL, NULL);
}

gssize aml_socket_receive(AmlSocket * socket, gchar * buffer, gsize size)
{
    return g_socket_receive(G_SOCKET(socket), buffer, size, NULL, NULL);
}

/* 读取一行 TODO */
gssize aml_socket_receive_line(AmlSocket * socket, gchar * buffer,
                               gsize size)
{
    return 0;
}

/*
 * 该函数会发送一个协议请求，
 * 然后等待响应，直到接受到了完整的响应（一个空行结束）才回调
 */
static void aml_socket_send_command_thread(GTask * task,
                                           gpointer source_object,
                                           gpointer task_data,
                                           GCancellable * cancellable)
{
    AmlSocket *socket = AML_SOCKET(source_object);
    const gchar *command = (gchar *) g_task_get_task_data(task);

    if (aml_socket_send(socket, command, -1) <= 0) {
        g_task_return_pointer(task, NULL, NULL);
    }
    GString *string = g_string_new("");
    gchar buf[4096];
    while (aml_socket_receive_line(socket, buf, sizeof(buf)) > 0) {
        /* TODO */
    }
}

void aml_socket_send_command_async(AmlSocket * socket,
                                   const gchar * command,
                                   GAsyncReadyCallback callback,
                                   gpointer user_data)
{
    GTask *task = g_task_new(socket, NULL, callback, user_data);
    g_task_set_task_data(task, g_strdup(command), (GDestroyNotify) g_free);
    g_task_run_in_thread(task, aml_socket_send_command_thread);
    aml_socket_set_busy(socket, TRUE);
}

gchar *aml_socket_send_command_finish(GAsyncResult * result)
{
    gchar *data = (gchar *) g_task_propagate_pointer(G_TASK(result), NULL);
    AmlSocket *socket =
        (AmlSocket *) g_task_get_source_object(G_TASK(result));
    aml_socket_set_busy(socket, FALSE);
    return data;
}
