/* lcmainwindow.c generated by valac 0.20.1, the Vala compiler
 * generated from lcmainwindow.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include "lcmainwindow.h"
#include "lctoolstack.h"
#include "lcapplicationview.h"
#include "lcaboutdialog.h"
#include "lcmyphone.h"
#include "lcadb.h"
#include "lcsocket.h"
#include "lcutil.h"
#include "lccommander.h"
#include "libadb/sysdeps.h"
#include "libadb/adb_client.h"
#include <time.h>

#define MAINWINDOW_TITLE "Android Manager"

#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define LC_MAIN_WINDOW_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_LC_MAIN_WINDOW, LcMainWindowPrivate))

static gpointer lc_main_window_parent_class = NULL;

#define APPLICATION_VIEW_NAME "app"
#define APPLICATION_VIEW_TITLE "Applications"
#define SMS_VIEW_NAME   "sms"
#define SMS_VIEW_TITLE  "SMS"

static void lc_main_window_finalize(GObject * obj);

/* create the menu bar, of course along with all menus */
static GtkWidget *lc_main_window_menu_bar(LcMainWindow * self);

static void _on_about_menu_item_activate(GtkMenuItem * item,
                                         gpointer data);


enum {
    LC_MAIN_WINDOW_DUMMY_PROPERTY
};

typedef enum {
    LC_PHONE_STATE_DISCONNECTED,
    LC_PHONE_STATE_CONNECTED,
    LC_PHONE_STATE_CONNECTING,
} LcPhoneState;

struct _LcMainWindowPrivate {
    LcApplicationView *app_view;
    LcToolStack *tool_stack;
    LcMyPhone *phone;

    LcPhoneState state;
};

#define _lc_main_window_get_application_view(self) ((self)->priv->app_view)
#define _lc_main_window_get_tool_stack(self)     ((self)->priv->tool_stack)
#define _lc_main_window_get_my_phone(self)       ((self)->priv->phone)

#define _lc_main_window_set_phone_state(self,_state)    ((self)->priv->state=_state)

#define _lc_main_window_set_phone_connected(self)    _lc_main_window_set_phone_state(self,LC_PHONE_STATE_CONNECTED)
#define _lc_main_window_set_phone_disconnected(self) _lc_main_window_set_phone_state(self,LC_PHONE_STATE_DISCONNECTED)
#define _lc_main_window_set_phone_connecting(self)   _lc_main_window_set_phone_state(self,LC_PHONE_STATE_CONNECTING)

#define _lc_main_window_is_connected(self)   ((self)->priv->state==LC_PHONE_STATE_CONNECTED)

LcMainWindow *lc_main_window_construct(GType object_type)
{
    LcMainWindow *self = NULL;
    self = (LcMainWindow *) g_object_new(object_type, NULL);
    return self;
}


LcMainWindow *lc_main_window_new(void)
{
    return lc_main_window_construct(TYPE_LC_MAIN_WINDOW);
}


static void lc_main_window_class_init(LcMainWindowClass * klass)
{
    lc_main_window_parent_class = g_type_class_peek_parent(klass);
    g_type_class_add_private(klass, sizeof(LcMainWindowPrivate));
    G_OBJECT_CLASS(klass)->finalize = lc_main_window_finalize;
}

static void _on_my_phone(gboolean visible, gpointer user_data)
{
    if (visible) {
        g_message("Come on, My Android!");
    }
}

static void _on_command_applications(const gchar * cmd, GByteArray * array,
                                     gpointer user_data)
{
    LcMainWindow *self = (LcMainWindow *) user_data;
    LcApplicationView *appView =
        _lc_main_window_get_application_view(self);
    gchar *result = lc_util_get_string_from_byte_array(array, NULL);
    if (result == NULL || lc_protocol_get_result_from_string(result) !=
        LC_PROTOCOL_RESULT_OKAY) {
        g_warning("Command '%s' Failed:%s", cmd, result);
    } else {
        GList *list =
            lc_protocol_create_application_list(result +
                                                LC_PROTOCOL_HDR_LEN);
        lc_application_view_update(appView, list);
        lc_protocol_free_application_list(list);
    }
    g_free(result);
    lc_application_view_set_loading(appView, FALSE);
}

static void _on_application(gboolean visible, gpointer user_data)
{
    LcMainWindow *self = (LcMainWindow *) user_data;
    LcApplicationView *view = _lc_main_window_get_application_view(self);

    guint64 last = lc_application_view_get_update_time(view);
    guint64 now = (guint64) time(NULL);

    if (visible && _lc_main_window_is_connected(self) &&
        lc_application_view_is_loading(view) == FALSE &&
        now - last >= 60) {
        lc_application_view_set_loading(view, TRUE);
        lc_commander_send_command_async(LC_PROTOCOL_APPLICATIONS,
                                        _on_command_applications,
                                        user_data);
    }
}

static void lc_main_window_my_phone_init(LcMainWindow * self);

static void lc_main_window_instance_init(LcMainWindow * self)
{
    self->priv = LC_MAIN_WINDOW_GET_PRIVATE(self);

    gtk_window_set_resizable(GTK_WINDOW(self), FALSE);
    gtk_widget_set_size_request(GTK_WIDGET(self), 900, 600);
    gtk_window_set_position(GTK_WINDOW(self), GTK_WIN_POS_CENTER);
    gtk_window_set_title(GTK_WINDOW(self), MAINWINDOW_TITLE);
    g_signal_connect(G_OBJECT(self), "destroy",
                     G_CALLBACK(gtk_main_quit), NULL);

    GtkWidget *rootBox = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);
    gtk_container_add(GTK_CONTAINER(self), rootBox);

    gtk_box_pack_start(GTK_BOX(rootBox), lc_main_window_menu_bar(self),
                       FALSE, FALSE, 0);

    self->priv->tool_stack = lc_tool_stack_new();
    gtk_box_pack_start(GTK_BOX(rootBox),
                       GTK_WIDGET(self->priv->tool_stack), TRUE, TRUE, 0);
    g_object_ref_sink(self->priv->tool_stack);

    lc_main_window_my_phone_init(self);
    lc_tool_stack_append(self->priv->tool_stack,
                         gtk_image_new_from_file
                         (lc_util_get_resource_by_name("smartphone.svg")),
                         "My Phone", GTK_WIDGET(self->priv->phone),
                         _on_my_phone, self);

    self->priv->app_view = lc_application_view_new();
    g_object_ref_sink(self->priv->app_view);
    lc_tool_stack_append(self->priv->tool_stack,
                         gtk_image_new_from_file
                         (lc_util_get_resource_by_name("computer.svg")),
                         "Applications", GTK_WIDGET(self->priv->app_view),
                         _on_application, self);

    _lc_main_window_set_phone_disconnected(self);
}

static void _on_connect_clicked(GtkWidget * button, gpointer data)
{
    LcMainWindow *self = (LcMainWindow *) data;
    lc_my_phone_show_connecting(self->priv->phone);
    lc_main_window_start_server(self);
    _lc_main_window_set_phone_connecting(self);
}

static void lc_main_window_my_phone_init(LcMainWindow * self)
{
    LcMyPhone *phone = lc_my_phone_new();
    lc_my_phone_set_connect_callback(phone,
                                     G_CALLBACK(_on_connect_clicked),
                                     self);
    g_object_ref_sink(phone);

    self->priv->phone = phone;
}

static void lc_main_window_finalize(GObject * obj)
{
    LcMainWindow *self =
        G_TYPE_CHECK_INSTANCE_CAST(obj, TYPE_LC_MAIN_WINDOW,
                                   LcMainWindow);
    _g_object_unref0(self->priv->app_view);
    _g_object_unref0(self->priv->tool_stack);
    _g_object_unref0(self->priv->phone);
    G_OBJECT_CLASS(lc_main_window_parent_class)->finalize(obj);
}


GType lc_main_window_get_type(void)
{
    static volatile gsize lc_main_window_type_id__volatile = 0;
    if (g_once_init_enter(&lc_main_window_type_id__volatile)) {
        static const GTypeInfo g_define_type_info =
            { sizeof(LcMainWindowClass), (GBaseInitFunc) NULL,
            (GBaseFinalizeFunc) NULL,
            (GClassInitFunc) lc_main_window_class_init,
            (GClassFinalizeFunc) NULL,
            NULL, sizeof(LcMainWindow), 0,
            (GInstanceInitFunc) lc_main_window_instance_init, NULL
        };
        GType lc_main_window_type_id;
        lc_main_window_type_id =
            g_type_register_static(GTK_TYPE_WINDOW, "LcMainWindow",
                                   &g_define_type_info, 0);
        g_once_init_leave(&lc_main_window_type_id__volatile,
                          lc_main_window_type_id);
    }
    return lc_main_window_type_id__volatile;
}

/* create menu bar, along with all menus */
static GtkWidget *lc_main_window_menu_bar(LcMainWindow * self)
{
    GtkWidget *menuBar = gtk_menu_bar_new();
    GtkWidget *aboutItem = gtk_menu_item_new_with_mnemonic("_About");
    gtk_menu_shell_append(GTK_MENU_SHELL(menuBar), aboutItem);

    GtkWidget *aboutMenu = gtk_menu_new();
    gtk_menu_item_set_submenu(GTK_MENU_ITEM(aboutItem), aboutMenu);

    GtkWidget *_aboutItem = gtk_menu_item_new_with_mnemonic("_About");
    gtk_menu_shell_append(GTK_MENU_SHELL(aboutMenu), _aboutItem);
    g_signal_connect(G_OBJECT(_aboutItem), "activate",
                     G_CALLBACK(_on_about_menu_item_activate), NULL);

    return menuBar;
}

/* show LcAboutDialog */
static void _on_about_menu_item_activate(GtkMenuItem * item, gpointer data)
{
    LcAboutDialog *dialog = lc_about_dialog_new();
    lc_about_dialog_run(dialog);
    lc_about_dialog_destroy(dialog);
}

void lc_main_window_show(LcMainWindow * window)
{
    gtk_widget_show_all(GTK_WIDGET(window));
    gtk_main();
}

static void onPhone(const gchar * cmd, GByteArray * array,
                    gpointer user_data)
{
    gchar *result = lc_util_get_string_from_byte_array(array, NULL);
    if (result == NULL
        || lc_protocol_get_result_from_string(result) !=
        LC_PROTOCOL_RESULT_OKAY) {
        g_warning("Command '%s' Failed:%s", LC_PROTOCOL_PHONE, result);
    } else {
        LcMainWindow *self = (LcMainWindow *) user_data;
        LcProtocolPhone *phone =
            lc_protocol_create_phone(result + LC_PROTOCOL_HDR_LEN);
        lc_my_phone_show_connected_with_info(self->priv->phone, phone);
        lc_protocol_phone_free(phone);
    }
    g_free(result);
}


static void _on_connection_init(LcCommanderInitResult result,
                                gpointer data)
{
    LcMainWindow *self = (LcMainWindow *) data;
    if (result == LC_COMMANDER_INIT_OK) {
        lc_commander_send_command_async(LC_PROTOCOL_PHONE, onPhone, data);
        lc_my_phone_show_connected(self->priv->phone);
        _lc_main_window_set_phone_connected(self);
    } else {
        /* Connection failed */
        lc_my_phone_show_disconnect(self->priv->phone);
        _lc_main_window_set_phone_disconnected(self);
    }
}

void lc_main_window_start_server(LcMainWindow * window)
{
    lc_commander_init_async(_on_connection_init, window);
}
