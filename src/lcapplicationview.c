/* LcApplicationView.c generated by valac 0.20.1, the Vala compiler
 * generated from LcApplicationView.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include "lcapplicationview.h"
#include "lcutil.h"
#include "lccommander.h"
#include <gtk/gtk.h>
#include <time.h>
#include <string.h>

#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

struct _LcApplicationViewPrivate {
    GtkTreeView *view;
    GtkListStore *store;

    gboolean loading;
    guint64 update_time;

    GtkMenu *popmenu;
};

#define _lc_application_view_get_list_store(self)    ((self)->priv->store)
#define _lc_application_view_get_tree_view(self)     ((self)->priv->view)
#define _lc_application_view_get_update_time(self)   ((self)->priv->update_time)
#define _lc_application_view_get_popmenu(self)       ((self)->priv->popmenu)


static gpointer lc_application_view_parent_class = NULL;

#define LC_APPLICATION_VIEW_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_LC_APPLICATION_VIEW, LcApplicationViewPrivate))
enum {
    LC_APPLICATION_VIEW_DUMMY_PROPERTY
};
static void lc_application_view_finalize(GObject * obj);

typedef enum {
    LC_APPLICATION_VIEW_COL_ICON,   /*图标 */
    LC_APPLICATION_VIEW_COL_NAME,   /*应用名 */
    LC_APPLICATION_VIEW_COL_VERSION,    /*版本号 */
    LC_APPLICATION_VIEW_COL_PACKAGE,    /* 包名 */

    LC_APPLICATION_VIEW_COL_XALIGN,

    LC_APPLICATION_VIEW_COL_FLAG,   /* 标记位, used in lc_application_view_update */
    LC_APPLICATION_VIEW_COL_NUMBER
} LcApplicationViewColumns;

#define ICON_SIZE           (48)
#define COLUMN_ICON_WIDTH   (100)
#define COLUMN_NAME_WIDTH   (150)
#define COLUMN_VERSION_WIDTH (120)
#define COLUMN_PACKAGE_WIDTH (140)

static gboolean _on_view_button_pressed(GtkWidget * widget,
                                        GdkEventButton * event,
                                        gpointer user_data);

LcApplicationView *lc_application_view_construct(GType object_type)
{
    LcApplicationView *self = NULL;
    self = (LcApplicationView *) g_object_new(object_type, NULL);
    gtk_container_add(GTK_CONTAINER(self), GTK_WIDGET(self->priv->view));
    g_signal_connect(G_OBJECT(self->priv->view), "button-press-event",
                     G_CALLBACK(_on_view_button_pressed), self);
    return self;
}


LcApplicationView *lc_application_view_new(void)
{
    return lc_application_view_construct(TYPE_LC_APPLICATION_VIEW);
}


static void lc_application_view_class_init(LcApplicationViewClass * klass)
{
    lc_application_view_parent_class = g_type_class_peek_parent(klass);
    g_type_class_add_private(klass, sizeof(LcApplicationViewPrivate));
    G_OBJECT_CLASS(klass)->finalize = lc_application_view_finalize;
}


static void lc_application_view_instance_init(LcApplicationView * self)
{
    self->priv = LC_APPLICATION_VIEW_GET_PRIVATE(self);

    LcApplicationViewPrivate *priv = self->priv;

    priv->popmenu = NULL;
    priv->loading = FALSE;
    priv->update_time = (guint64) 0;
    priv->store = (GtkListStore *)
        gtk_list_store_new(LC_APPLICATION_VIEW_COL_NUMBER,
                           GDK_TYPE_PIXBUF, G_TYPE_STRING, G_TYPE_STRING,
                           G_TYPE_STRING, G_TYPE_FLOAT, G_TYPE_INT);
    priv->view = (GtkTreeView *)
        gtk_tree_view_new_with_model(GTK_TREE_MODEL(priv->store));
    g_object_ref_sink(priv->store);
    g_object_ref_sink(priv->view);

    GtkCellRenderer *renderer;
    GtkTreeViewColumn *column;
    renderer = gtk_cell_renderer_pixbuf_new();
    column = gtk_tree_view_column_new_with_attributes("ICON", renderer,
                                                      "pixbuf",
                                                      LC_APPLICATION_VIEW_COL_ICON,
                                                      NULL);
    gtk_tree_view_column_set_fixed_width(column, COLUMN_ICON_WIDTH);
    gtk_tree_view_append_column(priv->view, column);

    renderer = gtk_cell_renderer_text_new();
    column = gtk_tree_view_column_new_with_attributes("NAME", renderer,
                                                      "text",
                                                      LC_APPLICATION_VIEW_COL_NAME,
                                                      "xalign",
                                                      LC_APPLICATION_VIEW_COL_XALIGN,
                                                      NULL);
    gtk_tree_view_column_set_fixed_width(column, COLUMN_NAME_WIDTH);
    gtk_tree_view_append_column(priv->view, column);

    renderer = gtk_cell_renderer_text_new();
    column = gtk_tree_view_column_new_with_attributes("VERSION", renderer,
                                                      "text",
                                                      LC_APPLICATION_VIEW_COL_VERSION,
                                                      "xalign",
                                                      LC_APPLICATION_VIEW_COL_XALIGN,
                                                      NULL);
    gtk_tree_view_column_set_fixed_width(column, COLUMN_VERSION_WIDTH);
    gtk_tree_view_append_column(priv->view, column);

    renderer = gtk_cell_renderer_text_new();
    column = gtk_tree_view_column_new_with_attributes("PACKAGE", renderer,
                                                      "text",
                                                      LC_APPLICATION_VIEW_COL_PACKAGE,
                                                      "xalign",
                                                      LC_APPLICATION_VIEW_COL_XALIGN,
                                                      NULL);
    gtk_tree_view_column_set_fixed_width(column, COLUMN_PACKAGE_WIDTH);
    gtk_tree_view_append_column(priv->view, column);
}


static void lc_application_view_finalize(GObject * obj)
{
    LcApplicationView *self;
    self =
        G_TYPE_CHECK_INSTANCE_CAST(obj, TYPE_LC_APPLICATION_VIEW,
                                   LcApplicationView);
    _g_object_unref0(self->priv->view);
    _g_object_unref0(self->priv->store);
    G_OBJECT_CLASS(lc_application_view_parent_class)->finalize(obj);
}


GType lc_application_view_get_type(void)
{
    static volatile gsize lc_application_view_type_id__volatile = 0;
    if (g_once_init_enter(&lc_application_view_type_id__volatile)) {
        static const GTypeInfo g_define_type_info =
            { sizeof(LcApplicationViewClass), (GBaseInitFunc) NULL,
            (GBaseFinalizeFunc) NULL,
            (GClassInitFunc) lc_application_view_class_init,
            (GClassFinalizeFunc) NULL, NULL, sizeof(LcApplicationView), 0,
            (GInstanceInitFunc) lc_application_view_instance_init, NULL
        };
        GType lc_application_view_type_id;
        lc_application_view_type_id =
            g_type_register_static(GTK_TYPE_SCROLLED_WINDOW,
                                   "LcApplicationView",
                                   &g_define_type_info, 0);
        g_once_init_leave(&lc_application_view_type_id__volatile,
                          lc_application_view_type_id);
    }
    return lc_application_view_type_id__volatile;
}

/*
 * Button Event of GtkTreeView 
 * pop up a context menu
 */
static gboolean _on_view_button_pressed(GtkWidget * widget,
                                        GdkEventButton * event,
                                        gpointer user_data)
{
    LcApplicationView *self = (LcApplicationView *) user_data;
    GtkMenu *menu = _lc_application_view_get_popmenu(self);
    if (event->type == GDK_BUTTON_PRESS &&
        event->button == 3 && menu != NULL) {
        gtk_menu_popup(menu, NULL, NULL, NULL, NULL, 3,
                       gdk_event_get_time((GdkEvent *) event));
        gtk_widget_show_all(GTK_WIDGET(menu));
    }
    return FALSE;
}

guint64 lc_application_view_get_update_time(LcApplicationView * self)
{
    return _lc_application_view_get_update_time(self);
}

static void _on_icon_saved(GObject * source_object, GAsyncResult * result,
                           gpointer data)
{
    gchar *package = g_file_get_basename(G_FILE(source_object));
    GtkListStore *store = (GtkListStore *) data;
    GtkTreeIter iter;
    if (gtk_tree_model_get_iter_first(GTK_TREE_MODEL(store), &iter)) {
        do {
            gchar *p = NULL;
            gtk_tree_model_get(GTK_TREE_MODEL(store), &iter,
                               LC_APPLICATION_VIEW_COL_PACKAGE, &p, -1);
            if (g_strstr_len(package, -1, p) == package) {
                GdkPixbuf *pixbuf =
                    lc_util_load_pixbuf_from_cache_with_size(package,
                                                             ICON_SIZE,
                                                             ICON_SIZE);
                gtk_list_store_set(store, &iter,
                                   LC_APPLICATION_VIEW_COL_ICON, pixbuf,
                                   -1);
                g_object_unref(pixbuf);
                break;
            }
            g_free(p);
        } while (gtk_tree_model_iter_next(GTK_TREE_MODEL(store), &iter));
    }
    g_free(package);
}

static void _on_command_icon(const gchar * cmd, GByteArray * array,
                             gpointer data)
{
    if (array == NULL) {
        g_warning("Connection Failed: %s", cmd);
        return;
    }
    GBytes *bytes = g_byte_array_free_to_bytes(array);
    if (lc_protocol_get_result_from_bytes(bytes) !=
        LC_PROTOCOL_RESULT_OKAY) {
        g_bytes_unref(bytes);
        g_warning("Protocol Failed: %s", cmd);
        return;
    }
    gsize size;
    gchar *content = g_bytes_unref_to_data(bytes, &size);
    gchar *package = g_strdup(cmd + 5);
    package[strlen(package) - 1] = '\0';
    const gchar *path = lc_util_get_image_cache_path_by_name(package);
    GFile *file = g_file_new_for_path(path);
    g_file_replace_contents_async(file, content + LC_PROTOCOL_HDR_LEN,
                                  size - LC_PROTOCOL_HDR_LEN, NULL, FALSE,
                                  G_FILE_CREATE_NONE, NULL, _on_icon_saved,
                                  data);
    g_free(package);
}

static void _lc_application_view_list_store_set(GtkListStore * store,
                                                GtkTreeIter * iter,
                                                LcProtocolApplication *
                                                info)
{
    GdkPixbuf *icon =
        lc_util_load_pixbuf_from_cache_with_size(info->package_name,
                                                 ICON_SIZE, ICON_SIZE);
    if (icon == NULL) {
        icon = lc_util_load_pixbuf_from_resouce("default-icon");
        lc_commander_send_command_async
            (lc_protocol_icon_command(info->package_name),
             _on_command_icon, store);
    }
    gtk_list_store_set(GTK_LIST_STORE(store), iter,
                       LC_APPLICATION_VIEW_COL_ICON,
                       icon,
                       LC_APPLICATION_VIEW_COL_NAME,
                       info->app_name,
                       LC_APPLICATION_VIEW_COL_VERSION,
                       info->version,
                       LC_APPLICATION_VIEW_COL_PACKAGE,
                       info->package_name, -1);
    g_object_unref(icon);
}

/*
 * update ALl application infomation
 * 
 * remove update and insert
 */
void lc_application_view_update(LcApplicationView * self, GList * list)
{
    if (list == NULL) {
        return;
    }
    self->priv->update_time = (guint64) time(NULL);
    GtkTreeIter iter;
    GtkTreeModel *model =
        (GtkTreeModel *) _lc_application_view_get_list_store(self);
    GList *add = g_list_copy(list);
    if (gtk_tree_model_get_iter_first(model, &iter)) {
        while (gtk_list_store_iter_is_valid(GTK_LIST_STORE(model), &iter)) {
            gchar *package = NULL;
            gtk_tree_model_get(model, &iter,
                               LC_APPLICATION_VIEW_COL_PACKAGE, &package,
                               -1);
            LcProtocolApplication *app =
                lc_protocol_application_find(list, package);
            g_free(package);
            if (app == NULL) {
                /* not found, delete */
                gtk_list_store_remove(GTK_LIST_STORE(model), &iter);
            } else {
                /* found, update */
                _lc_application_view_list_store_set(GTK_LIST_STORE(model),
                                                    &iter, app);
                gtk_tree_model_iter_next(model, &iter);
                add = g_list_remove(add, app);
            }
        }
    }

    /* add the new elements */
    GList *lp = add;
    while (lp) {
        LcProtocolApplication *app = lp->data;
        gtk_list_store_append(GTK_LIST_STORE(model), &iter);
        _lc_application_view_list_store_set(GTK_LIST_STORE(model), &iter,
                                            app);
        lp = g_list_next(lp);
    }
    g_list_free(add);
}

/*
 * 在应用列表中增加一项，不会检查是否重复
 */
void lc_application_view_append(LcApplicationView * self,
                                LcProtocolApplication * data)
{
    GtkListStore *store = self->priv->store;
    GtkTreeIter iter;

    gtk_list_store_append(store, &iter);
    gtk_list_store_set(store, &iter,
                       LC_APPLICATION_VIEW_COL_NAME,
                       data->app_name,
                       LC_APPLICATION_VIEW_COL_VERSION,
                       data->version,
                       LC_APPLICATION_VIEW_COL_PACKAGE,
                       data->package_name, -1);
}

void lc_application_view_set_loading(LcApplicationView * self,
                                     gboolean loading)
{
    self->priv->loading = loading;
}

gboolean lc_application_view_is_loading(LcApplicationView * self)
{
    return self->priv->loading;
}

void lc_application_view_set_popmenu(LcApplicationView * self,
                                     GtkMenu * menu)
{
    GtkMenu *o = _lc_application_view_get_popmenu(self);
    if (o) {
        g_object_unref(o);
    }
    self->priv->popmenu = menu;
}
